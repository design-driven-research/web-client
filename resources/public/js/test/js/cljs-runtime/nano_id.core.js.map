{"version":3,"sources":["nano_id/core.cljc"],"mappings":";AAMA,AAAKA,wBACH,2DAAA,3DAACC,6CAAKC;AAER,AAAA;;;;uBAAA,+BAAAC,tDAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,mDAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,qDAAA,rDAAMD;AAAN,AAKY,0DAAA,nDAACE;;;AALb,CAAA,qDAAA,rDAAMF,gEAMFG;AANJ,AAOG,GAAQ,QAAA,PAAMA;AAAd;AAAA,AAAA,MAAA,KAAAF,MAAA,CAAA,kBAAA,yBAAA,KAAA;;;AAES,WAAA,PAAMG;AAAN,AACE,IAAOC,QAAM,AAACC,4BAAiBH;SAA/B,LACOI;;AADP,AAEK,oBAAIF;AACF,eAAO,AAACG,eAAKH;mGACD,AAACI,gBAAMJ,xBACP,CAASD,7EAET,gDAAA,iBAAAM,hEAAKH;QADLZ,sDAAAA,gEAAAA,9HACA,AAAA,kHAAAe,4CAAAA;;;;;;AACZH;;;;;;AAlBrB,CAAA,+CAAA,/CAAMP;;AAAN,AAoBA,AAAA;;;;;;;sBAAA,8BAAAF,pDAAMc;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAX,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAMW,+DAMFC,SAASV;AANb,AAOG,OAACW,kDAAOD,SAASV,KAAKG;;;AAPzB,CAAA,oDAAA,pDAAMM,+DAQFC,SAASV,KAAKY;AARlB,AASG,GAAQ,EAAA,CAAA,uCAAA,8BAAA,9DAAM,iCAAA,jCAACC,iCAAAA,jBAAMH,iCAAAA;AAArB;AAAA,AAAA,MAAA,KAAAZ,MAAA,CAAA,kBAAA,kDAAA,KAAA;;;AACA,GAAQ,QAAA,PAAME;AAAd;AAAA,AAAA,MAAA,KAAAF,MAAA,CAAA,kBAAA,yBAAA,KAAA;;;AACA,IAAMY,eAA4D,AAACjB,6CAAKC,cAAIgB;IACtEI,SAAc,AAACD,gBAAMH;IACrBK,sBAAc,+BAAA,9BAAO,CAASD,SAAO,UAAA,TAAKA;IAC1Cb,OAAc,EAAIc,qBACF,UAAA,TAAKD,cACL,uDAAA,tDAAK,CAAA,OAAkB,sCAAA,rCAAK,CAAG,AAACE,SAASF,UAAQ,SAAA,TAACE;IAClEC,OAAc,EAAIF,qBACFf,KACA,+CAAA,9CAAK,AAACkB,UAAU,CAAG,CAAA,gBAAA,fAAGlB,OAAKC,eAAUa;AAR3D,AASE;AAAA,AAEW,IAAOZ,QAAM,CAACU,uCAAAA,6CAAAA,RAAOK,yBAAAA;SAArB,LACOb;;AADP,AAEE,GAAI,CAAI,EAAOA,gBAAIJ;AACjBI;;AACA,eAAO,iBAAAe,mBAAI,AAACd,eAAKH;AAAV,AAAA,GAAAiB;AAAAA;;AAAiB,QAACP,uCAAAA,6CAAAA,RAAOZ,yBAAAA;;;eACzB,iBAAAoB,qBAAY,AAACE,4CAAIZ,aAAS,CAAS,AAACJ,gBAAMJ,SAAOD;AAAjD,AAAA,oBAAAmB;AAAA,SAAAA,LAASC;AAAT,AACE,QAAKjB,+CAAGiB;;AACRjB;;;;;;;;;;;;AA7B7B,CAAA,8CAAA,9CAAMK;;AAAN","names":["nano-id.core/alphabet","cljs.core.mapv","cljs.core/str","var_args","G__47616","nano-id.core/nano-id","js/Error","nano_id.core.nano_id","size","mask","bytes","nano-id.random/random-bytes","id","cljs.core/next","cljs.core/first","G__47629","G__47635","nano-id.core/custom","alphabet","nano_id.core.custom","random","cljs.core/count","length","power-of-two?","Math/log","step","Math/ceil","or__4212__auto__","temp__5751__auto__","ch","cljs.core.get"],"sourcesContent":["(ns nano-id.core\n  (:require [nano-id.random :as rnd])\n  #?(:clj (:import nano_id.NanoID)))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(def alphabet\n  (mapv str \"_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\n(defn nano-id\n  \"Secure random ID generator.\n  Generates IDs of the specified size, 21 by default.\"\n  ([]\n   #?(:clj  (NanoID/nanoID)\n      :cljs (nano-id 21)))\n  ([size]\n   (assert (pos? size) \"size must be positive.\")\n   #?(:clj  (NanoID/nanoID size)\n      :cljs (let [mask 0x3f]\n              (loop [bytes (rnd/random-bytes size)\n                     id \"\"]\n                   (if bytes\n                     (recur (next bytes)\n                            (->> (first bytes)\n                                 (bit-and mask)\n                                 alphabet\n                                 (str id)))\n                     id))))))\n\n(defn custom\n  \"Builds ID generator with custom parameters.\n  Takes alphabet and size. alphabet must contain 256 symbols or less; otherwise,\n  the generator won't be secure.\n  Also you can provide your own random bytes generator. It should be a function\n  that takes one argument - number of bytes, and returns a byte array.\"\n  ([alphabet size]\n   (custom alphabet size rnd/random-bytes))\n  ([alphabet size random]\n   (assert (<= 2 (count alphabet) 256) \"alphabet must contain from 2 to 256 characters.\")\n   (assert (pos? size) \"size must be positive.\")\n   (let [alphabet      #?(:clj (.toCharArray ^String alphabet) :cljs (mapv str alphabet))\n         length        (count alphabet)\n         power-of-two? (zero? (bit-and length (dec length))) ;; https://bit.ly/ispow2\n         mask          (if power-of-two?\n                         (dec length)\n                         (dec (bit-shift-left 2 (int (/ (Math/log length) (Math/log 2))))))\n         step          (if power-of-two?\n                         size\n                         (int (Math/ceil (/ (* size mask 1.1) length))))]\n     (fn []\n       #?(:clj  (NanoID/custom alphabet size random step mask)\n          :cljs (loop [bytes (random step)\n                       id    \"\"]\n                  (if (== (count id) size)\n                    id\n                    (recur (or (next bytes) (random size))\n                           (if-let [ch (get alphabet (bit-and (first bytes) mask))]\n                             (str id ch)\n                             id)))))))))\n"]}