{"version":3,"sources":["rdd/converters/uom.cljs"],"mappings":";AAOA;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA,vDAAMA,sHAwBHC;AAxBH,AAyBE,OAACC,+CACA,eAAAC,JACGI;AADH,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;oBAAA,AAAAE,4CAAAF,eAAA,3EACeI;kBADf,AAAAF,4CAAAF,eAAA,zEAC6BK;eAD7B,AAAAH,4CAAAF,eAAA,tEACyCM;AADzC,0BAEM,uBAAA,vBAACC,mBAASJ,uFAAKE,YAAYD,sBAAe,CAAA,MAAKE,7KAC/C,wLAAA,jLAACC,oQAAUH,cAAcC,oBAAaC;GAJ7C,mCAKIT;;AAEN;;;;;;;;;qCAAA,rCAAMW,kFAQHF,SAASG,KAAKC,GAAGC;AARpB,AASE,GAAI,AAACC,6CAAEH,KAAKC;AAAZ,kDAAA,uEAAA,0DAAA,mDAAA,0DAAA,IAAA,pLACaJ,8DACJG,qDACFC,wHAEGJ;;AACR,IAAMO,QAAM,AAACC,wGAAQH;IACfI,OAAK,AAACC,iBAAYH,MAAMJ,KAAKC;IAC7BO,sBAAc,SAAA,RAAMF;IACpBG,SAAO,AAACpB,+CAAO,WAAAqB,SAA2BI;AAA3B,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAnB,4BAAAmB;aAAA,AAAAlB,4CAAAkB,eAAA,pEAAaC;WAAb,AAAAnB,4CAAAkB,eAAA,lEAAoBE;AAApB,AACE,IAAMD,aAAO,yFAAA,vEAAIC,MACF,CAAGD,SAAO,AAACnB,4CAAIoB,KAAKC;AADnC,AAAA,kDAAA,qEAAA,XAGWF,gEACF,AAACnB,4CAAIS,QAAQY;GALhC,mCAK2CR;IAClDM,SAAO,AAAA,wFAASH;AATtB,AAUE,GAAID;AAAJ,kDAAA,iEAAA,KAAA,gEAEc,mBAAA,nBAACO,yDAAqDf,KAAKC;;AAFzE,kDAAA,uEAAA,0DAAA,mDAAA,iEAAA,vLAGaJ,8DACJG,qDACFC,6DACIW,8DACD,CAAGf,WAASe;;;;AAE5B;;;;;;;;;6CAAA,7CAAMI,kGAQHhB,KAAKC,GAAGC;AARX,AASE,GAAI,AAACC,6CAAEH,KAAKC;AAAZ;;AAEE,IAAMG,QAAM,AAACC,wGAAQH;IACfI,OAAK,AAACC,iBAAYH,MAAMJ,KAAKC;AADnC,AAEE,OAACgB,mBAAQX","names":["rdd.converters.uom/generate-conversions-lookup-table","conversions","cljs.core.reduce","p__52720","map__52723","cljs.core/--destructure-map","cljs.core.get","acc","from-uom-code","to-uom-code","quantity","cljs.core/assoc-in","rdd.converters.uom/quantity-in-uom","from","to","mapping","cljs.core._EQ_","graph","loom.graph.graph","path","loom.alg/bf-path","missing-path?","result","p__52725","map__52727","factor","head","cur","goog.string/format","rdd.converters.uom/has-path-from-to?","cljs.core/boolean"],"sourcesContent":["(ns rdd.converters.uom\n  (:require [clojure.set]\n            [goog.string :as gstring]\n            [goog.string.format]\n            [loom.alg :as alg]\n            [loom.graph :as g]))\n\n(defn generate-conversions-lookup-table\n  \"Takes a set of conversions and generates a lookup table. \n   \n   Required keys for each entry: :from-uom-code :to-uom-code :quantity\n   \n   '#{{:conversion-uuid 'Nhs-KWvQjyf-D2YMZM7bP', :from-uom-code 'kg', :to-uom-code 'gr', :quantity 1000}\n     {:conversion-uuid 'ZqGv_fqNsZw0Zem7F2mLm', :from-uom-code 'gr', :to-uom-code 'gr', :quantity 1}\n     {:conversion-uuid 'HrsYuIva9akIEH_0fQiGG', :from-uom-code 'pallet', :to-uom-code 'case', :quantity 50}\n     {:conversion-uuid 'OciR1EXFmdsYe075q3szn', :from-uom-code 'lb', :to-uom-code 'gr', :quantity 453.1}\n     {:conversion-uuid '9NpI7YvNXdjqeu9yNM9NT', :from-uom-code 'case', :to-uom-code 'lb', :quantity 25}}'\n   \n   Returns:\n\n   {'gr' {'kg' 0.001, 'gr' 1, 'lb' 0.0022070183182520413}\n    'kg' {'gr' 1000}\n    'lb' {'gr' 453.1, 'case' 0.04}\n    'case' {'lb' 25, 'pallet' 0.02}\n    'pallet' {'case' 50}}\n   \n   Example:\n   ```clojure\n   (generate-conversions-lookup-table conversions)\n   ```\n   \"\n  [conversions]\n  (reduce\n   (fn\n     [acc {:keys [from-uom-code to-uom-code quantity]}]\n     (-> (assoc-in acc [to-uom-code from-uom-code] (/ 1 quantity))\n         (assoc-in [from-uom-code to-uom-code] quantity)))\n   {} conversions))\n\n(defn quantity-in-uom\n  \"Convert quantity from one UOM or a different UOM based on the conversion passed in.\n   \n   Example: (quantity-in-uom 5 :case :lb conversions)\n   \n   Returns: {:quantity 5, :from :case, :to :lb, :factor 25, :total 125}\n\n   Returns error map if no path is found: {:has-error? true, :error-msg 'No path was found between :case and :lbs'}\"\n  [quantity from to mapping]\n  (if (= from to)\n    {:quantity quantity\n     :from from\n     :to to\n     :factor 1\n     :total quantity}\n    (let [graph (g/graph mapping)\n          path (alg/bf-path graph from to)\n          missing-path? (nil? path)\n          result (reduce (fn [{:keys [factor head]} cur]\n                           (let [factor (if head\n                                          (* factor (get head cur))\n                                          1)]\n                             {:factor factor\n                              :head (get mapping cur)})) {} path)\n          factor (:factor result)]\n      (if missing-path?\n        {:has-error? true\n         :error-msg (gstring/format \"No path was found between %s and %s\" from to)}\n        {:quantity quantity\n         :from from\n         :to to\n         :factor factor\n         :total (* quantity factor)}))))\n\n(defn has-path-from-to?\n  \"Convert quantity from one UOM or a different UOM based on the conversion passed in.\n   \n   Example: (quantity-in-uom 5 :case :lb conversions)\n   \n   Returns: {:quantity 5, :from :case, :to :lb, :factor 25, :total 125}\n\n   Returns error map if no path is found: {:has-error? true, :error-msg 'No path was found between :case and :lbs'}\"\n  [from to mapping]\n  (if (= from to)\n    true\n    (let [graph (g/graph mapping)\n          path (alg/bf-path graph from to)]\n      (boolean path))))\n"]}